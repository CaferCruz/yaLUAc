// CUP specification for a simple expression evaluator (no actions)

import java_cup.runtime.*;
import lexico.Yylex;
import java.io.FileReader;
import lexico.Tokens.*;

parser code
{:
    public static void main(String args[]) throws Exception{
        Parser parser = new Parser();
        parser.setScanner(new Yylex(new FileReader(args[0])));
        parser.parse();
        //new parser(new Yylex(new FileInputStream(args[0]))).parser();
        //new parser(new Yylex(System.in)).parser();
    } 

    public void syntax_error(Symbol s){
        report_error("Error de sintaxe. Linha: " + (s.right) + " Coluna: " + s.left + ". Texto: \"" + s.value + "\"", null);
        //public static void carregar(String arquivo) throws Exception{
            //new parser(new Yylex(new FileInputStream(arquivo))).parser();
        //}
    }
:};

/* Preliminaries to set up and use the scanner.  */
init with {:               :};
scan with {: return getScanner().next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal String     t_SEMICOLON,
                    t_ATTRIBUTION, 
                    t_END,
                    t_DO,
                    t_WHILE,
                    t_REPEAT,
                    t_UNTIL,
                    t_IF,
                    t_THEN,
                    t_ELSEIF,
                    t_ELSE,
                    t_FOR,
                    t_IN,
                    t_FUNCTION, 
                    t_LOCAL,
                    t_RETURN,
                    t_BREAK,
                    t_DOT,
                    t_COLON,
                    t_COMMA,
                    t_BRACKET_OPEN,
                    t_BRACKET_CLOSE,
                    t_NIL,
                    t_TRUE,
                    t_FALSE,
                    t_PARENTHESE_OPEN,
                    t_PARENTHESE_CLOSE,
                    t_BRACERS_OPEN,
                    t_BRACERS_CLOSE,
                    t_DOTDOTDOT,
                    t_PLUS,
                    t_MINUS,
                    t_TIMES,
                    t_DEVIDED,
                    t_EXP,
                    t_PERCENT,
                    t_DOTDOT,
                    t_LESS_THEN,
                    t_LESS_EQUAL,
                    t_GREATER_THEN,
                    t_GREATER_EQUAL,
                    t_EQUAL,
                    t_NOT_EQUAL,
                    t_AND,
                    t_OR, 
                    t_NOT,
                    t_HASHTAG,
                    t_STRING,
                    t_BLANK,
                    t_NAME;
terminal Integer    t_NUMBER;

/* Non terminals */
non terminal block 
            ,statlist 							
            ,prefixexp 		
            ,stat 		
            ,laststat						
            ,optexplist 
            ,function 
            ,funcname 				
            ,optelse							
            ,optforexp 
            ,varlist 		
            ,explist					
            ,optasmexplist 					 		
            ,namelist 	
            ,var 			
            ,exp 
            ,functioncall 			
            ,args 
            ,funcbody 
            ,optparlist 		
            ,parlist 
            ,tableconstructor 				
            ,fieldlist 						
            ,field
            ,fieldsep
            ,binop					
            ,unop														
            ,optsemi
            ,empty;

/* Precedences */
precedence left t_OR;
precedence left t_AND;
precedence left t_LESS_THEN, t_GREATER_THEN, t_LESS_EQUAL, t_GREATER_EQUAL,t_NOT_EQUAL, t_EQUAL;
precedence left t_DOTDOT;
precedence left t_PLUS, t_MINUS;
precedence left t_TIMES, t_DEVIDED, t_PERCENT;
precedence left t_NOT;
precedence left t_EXP;


/* The grammar */
start with block;
 
block ::= statlist:s laststat:l {: RESULT = new Block1(s,l); :}
          | statlist:s {: RESULT = new Block2(s); :}
          | laststat:l {: RESULT = new Block3(l); :}
          | empty:e    {: RESULT = new Block4(e); :} ;

statlist ::= stat:s optsemi:o {: RESULT = new StatList1 (s,o); :}
            | stat:s optsemi:o  statlist:sl {: RESULT = new StatList2(s,o,sl); :};
										
prefixexp ::= var:v {: RESULT = new PrefiExp1(v); :}
            | functioncall:f {: RESULT = new PrefiExp2(f); :}
            | t_PARENTHESE_OPEN exp:e t_PARENTHESE_CLOSE {: RESULT = new PrefiExp3(new Folha(t_PARENTHESE_OPEN,"("),e,new Folha(t_PARENTHESE_CLOSE,")")); :}
            ;
				
stat ::= varlist:v t_ATTRIBUTION explist:e {: RESULT = new Stat1(v,new Folha(t_ATTRIBUTION,"="),e); :}
        | functioncall:f                       {: RESULT = new Stat2(f); :}
        | t_DO block:b t_END                     {: RESULT = new Stat3(new Folha(t_DO,"do"), t, new Folha(t_END,"end")); :}
        | t_WHILE exp:e t_DO block:b t_END          {: RESULT = new Stat4(new Folha(t_WHILE,"while"), e, new Folha(t_DO,"do"), b,new Folha(t_END,"end"); :}
        | t_REPEAT  block:b  t_UNTIL  exp:e         {: RESULT = new Stat5(new Folha(t_REPEAT,"repeat"), b, new Folha(t_UNTIL,"until"), e); :}
        | t_IF exp:e t_THEN block:b optelse:o t_END       {: RESULT = new Stat6(new Folha(t_IF,"if"), e, new Folha(t_THEN,"then"), b, o, new Folha(t_END, "end"); :}
        | t_FOR  t_NAME:n t_ATTRIBUTION exp:e1 t_COMMA exp:2  optforexp:o  t_DO  block:b t_END   {: RESULT = new Stat7(new Folha(t_FOR, "for"), new Folha(t_NAME,n), new Folha(t_ATTRIBUTION, "="),e1,new Folha(t_COMMA, ","), e2, o, new Folha(t_DO,"do"), b,new Folha(t_END,"end")); :}
        | t_FOR namelist:n  t_IN  explist:e  t_DO  block:b t_END   {: RESULT = new Stat8(new Folha(t_FOR,"for"), n,  new Folha(t_IN,"in"), e, new Folha( t_DO, "do"), b, new Folha(t_END,"end")); :}
        | t_FUNCTION  funcname:fn funcbody:fb                   {: RESULT = new Stat9(new Folha(t_FUNCTION,"function") , fn, fb); :}  
        | t_LOCAL t_FUNCTION  t_NAME:n  funcbody:f                  {: RESULT = new Stat10(new Folha(t_LOCAL,"local"), new Folha(t_FUNCTION,"function"),  new Folha(t_NAME,n), f); :}
        | t_LOCAL  namelist:n optasmexplist:o                      {: RESULT = new Stat11(new Folha(t_LOCAL,"local"), n, o); :} ;
					
laststat ::= t_RETURN  optexplist:o 	{: RESULT = new LastStat1(new Folha(t_RETURN,"return"),o); :}
            | t_BREAK 			{: RESULT = new LastStatFolha(new Folha(t_BREAK,"break")); :}	;		

optexplist ::= explist:e                {: RESULT = new OptExpList1(e); :}
               | empty:e               {: RESULT = new OptExpList2(e); :}    ;

function ::= t_FUNCTION funcbody:f;       {: RESULT = new Function(new Folha(t_FUNCTION, "function") , f); :}    

funcname ::= t_NAME:t                          {: RESULT = new FuncNameFolha(new Folha(t_NAME, t)); :} 
            | t_NAME t_DOT funcname:f          {: RESULT = new FuncName1(new Folha(t_NAME, t), new Folha(t_DOT,"."), f); :}
            | t_NAME:t1 t_COLON:t2 t_NAME:t3  {: RESULT = new FuncName2(new Folha(t_NAME, t1), new Folha(t_COLON, t2), new Folha(t_NAME, t3)); :}  ;
						

optelse	::= t_ELSE  block:b 				     {: RESULT = new OptElse1(new Folha(t_ELSE, "else"), b); :} 		
            | t_ELSEIF exp:e t_THEN  block:b optelse:o       {: RESULT = new OptElse1(new Folha(t_ELSEIF, "elseif"),e , new Folha(t_THEN, "then"), b, o); :} 
            | empty:e                                        {: RESULT = new OptElse1(e); :}     
            ;	
												
optforexp ::= t_COMMA exp:e				    {: RESULT = new OptForExp1(new Folha(t_COMA,",") , e); :}
            | empty:e                                      {: RESULT = new OptForExp2(e); :} ;

varlist ::= var:v                              {: RESULT = new VarList1(v); :}                
           | var:v t_COMMA varlist:vl         {: RESULT = new VarList2(v, new Folha(t_COMA, ","), vl); :}    ;                             
					
explist	::= exp:e                              {: RESULT = new ExpList1(e); :}                 
            | exp:e t_COMMA explist:el        {: RESULT = new ExpList1(e, new Folha(t_COMA,","), el); :} ;
						
optasmexplist ::= t_ATTRIBUTION explist:e        {: RESULT = new OptAsmExpList1(new Folha(t_ATTRIBUTION,"="), e); :}
                | empty:e		         {: RESULT = new OptAsmExpList2(e); :}  ;
						 		
namelist ::= t_NAME:t                              {: RESULT = new NameListFolha(new Folha(t_NAME,t)); :}   
            |  t_NAME:t t_COMMA namelist:n         {: RESULT = new NameList1(new Folha(t_NAME, t), new Folha(t_COMA,","), n); :} ;
					
var ::= t_NAME:t                                            {: RESULT = new VarFolha(new Folha(t_NAME, t)); :}          
        | prefixexp:p t_BRACKET_OPEN exp:e t_BRACKET_CLOSE      {: RESULT = new Var1(p, new Folha(t_BRACKET_OPEN, "["), e, new Folha(t_BRACKET_CLOSE, "]")); :}
        | prefixexp t_DOT t_NAME                           {: RESULT = new Var2(p , new Folha(t_DOT, "."), new Folha(t_NAME, t)); :}   ;

					
exp ::= t_NIL                   {: RESULT = new ExpFolha(new Folha(t_NIL,"NIL")); :}
        | t_FALSE               {: RESULT = new ExpFolha(new Folha(t_FALSE,"false")); :}
        | t_TRUE                {: RESULT = new ExpFolha(new Folha(t_TRUE,"true")); :}
        | t_NUMBER:n            {: RESULT = new ExpFolha(new Folha(t_NUMBER,n)); :}
        | t_STRING              {: RESULT = new ExpFolha(new Folha(t_STRING, "string")); :}
        | t_DOTDOTDOT           {: RESULT = new ExpFolha(new Folha(t_DOTDOTDOT,"...")); :}
        | function:f            {: RESULT = new Exp1(f); :}                
        | prefixexp:p           {: RESULT = new Exp2(p); :}
        | tableconstructor:t    {: RESULT = new Exp3(t); :}
        | exp:e1 binop:b exp:e2 {: RESULT = new Exp4(e1, b, e2); :}
        | unop:u exp:e         {: RESULT = new Exp5(u, e); :}   ;
	
functioncall ::= prefixexp:f args:a                  {: RESULT = new FunctionCall1(f, a); :}
                | prefixexp:p t_COLON t_NAME:t args:a      {: RESULT = new FunctuinCall2(p, new Folha(t_COLON,":"), new Folha(t_NAME,t), a); :}   ;
                
				
args ::= t_PARENTHESE_OPEN optexplist:o t_PARENTHESE_CLOSE   {: RESULT = new Args2(new Folha(t_PARENTHESE_OPEN, "(" ) , o, new Folha(t_PARENTHESE_CLOSE, ")")); :}
        | tableconstructor:t                                 {: RESULT = new Args1(t); :}                   
        | t_NAME:t                                          {: RESULT = new ArgsFolha(new Folha (t_NAME, t)); :}   ;

funcbody ::= t_PARENTHESE_OPEN optparlist:o t_PARENTHESE_CLOSE  block:b  t_END {: RESULT = new FuncBody(new Folha(t_PARENTHESE_OPEN,"("), o, new Folha(t_PARENTHESE_CLOSE,")"), b, new Folha(t_END, "end")))); :} ;

optparlist ::= parlist:p      {: RESULT = new OptParList1(p); :}
              | empty:e      {: RESULT = new OptParList2(e); :}		;

parlist ::= namelist:n                        {: RESULT = new NameList1(n); :}
            | namelist:n t_COMMA t_DOTDOTDOT  {: RESULT = new NameList2(n, new Folha(t_COMA,","), new Folha(t_DOTDOTDOT, "...")); :}
            | t_DOTDOTDOT                    {: RESULT = new NameList1(new Folha(t_DOTDOTDOT,"...")); :} ;
	

tableconstructor ::= t_BRACERS_OPEN fieldlist:f t_BRACERS_CLOSE  {: RESULT = new TableConstructor1(new Folha(t_BRACERS_OPEN, "{"), f, new Folha(t_BRACERS_CLOSE, "}")); :}
                    | t_BRACERS_OPEN t_BRACERS_CLOSE            {: RESULT = new TableConstructor2(new Folha(t_BRACERS_OPEN, "{"), new Folha(t_BRACERS_CLOSE, "}")); :}   ;
 						
fieldlist ::= field:f                         {: RESULT = new FieldList1(f); :}
            | field:f fieldsep:fs fieldlist:fl  {: RESULT = new FieldList2(f, fs, fl); :} ;
 										
field ::= t_BRACKET_OPEN exp:e1 t_BRACKET_CLOSE t_ATTRIBUTION exp:e2  {: RESULT = new Field1(new Folha(t_BRACKET_OPEN, "["), e1, new Folha(t_BRACKET_CLOSE, "]"), new Folha(t_ATTRIBUTION, "="), e2)); :}
        | t_NAME:t t_ATTRIBUTION exp:e                                {: RESULT = new Field2( new Folha(t_NAME, t ), new Folha(t_ATTRIBUTION, "="), e); :}                      
        | exp:e                                                        {: RESULT = new Field3(e); :}    ;      
						
fieldsep ::= t_COMMA                {: RESULT = new FieldSepFolha(new Folha(t_COMA,",")); :}
            | t_SEMICOLON          {: RESULT = new FieldSepFolha(new Folha(t_SEMICOLON,";")); :} ;
		
binop ::= t_PLUS                    {: RESULT = new BinOpFolha(new Folha(t_PLUS,"+")); :}
        | t_MINUS                   {: RESULT = new BinOpFolha(new Folha(t_MINUS,"-")); :}            
        | t_TIMES                   {: RESULT = new BinOpFolha(new Folha(t_TIMES,"*")); :}
        | t_DEVIDED                 {: RESULT = new BinOpFolha(new Folha(t_DEVIDED,"/")); :}
        | t_PERCENT                 {: RESULT = new BinOpFolha(new Folha(t_PERCENT,"%")); :}
        | t_EXP                     {: RESULT = new BinOpFolha(new Folha(t_EXP,"^")); :}
        | t_DOTDOT                  {: RESULT = new BinOpFolha(new Folha(t_DOTDOT,"..")); :}
        | t_EQUAL                   {: RESULT = new BinOpFolha(new Folha(t_EQUAL,"==")); :}
        | t_LESS_EQUAL              {: RESULT = new BinOpFolha(new Folha(t_LESS_EQUAL,"<=")); :}    
        | t_NOT_EQUAL               {: RESULT = new BinOpFolha(new Folha(t_NOT_EQUAL,"~=")); :}
        | t_LESS_THEN               {: RESULT = new BinOpFolha(new Folha(t_LESS_THEN,"<")); :}
        | t_GREATER_THEN            {: RESULT = new BinOpFolha(new Folha(t_GREATER_THEN,">")); :}
        | t_GREATER_EQUAL           {: RESULT = new BinOpFolha(new Folha(t_GREATER_EQUAL,"")); :}
        | t_AND                     {: RESULT = new BinOpFolha(new Folha(t_AND,"and")); :}
        | t_OR                     {: RESULT = new BinOpFolha(new Folha(t_OR,"or")); :}  ;
						
unop ::= t_MINUS                    {: RESULT = new UnOpFolha(new Folha(t_MINUS,"-")); :}
        | t_NOT                     {: RESULT = new BinOpFolha(new Folha(t_NOT,"not")); :}
        | t_HASHTAG                {: RESULT = new BinOpFolha(new Folha(t_HASHTAG,"#")); :}    ;
														
optsemi ::= t_SEMICOLON  {: RESULT = new OpSemiFolha(new Folha(t_SEMICOLON,";")); :}  
            | empty:e         {: RESULT = new OptSemi1(e); :} ;
                
empty ::=  t_BLANK         {: RESULT = new EmptyFolha(new Folha(t_BLANK," ")); :} ;